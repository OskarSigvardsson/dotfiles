Oskars emacs configuration file

* Basic emacs options
** Fix path
Fix the path so that homebrew stuff is included.

#+BEGIN_SRC emacs-lisp
  (setenv "PATH" (concat (getenv "PATH") ":/usr/local/bin"))
#+END_SRC

** Start server
Start the server so that you can use emacsclient. To edit a file from
the terminal use `emacs-edit`

#+BEGIN_SRC emacs-lisp
  (server-start)
#+END_SRC
** Custom file
Don't want the custom file polluting the main config file

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file)
#+END_SRC
** Disable clipboard integration with registers
Emacs clobbers the clipboard a little too readily, so I'm going to try
turning the automatic integration off. Still enable it with regular Cmd-C/X/V

#+BEGIN_SRC emacs-lisp
  (setq select-enable-clipboard nil)
  (global-set-key (kbd "s-c") 'clipboard-kill-ring-save)
  (global-set-key (kbd "s-v") 'clipboard-yank)
  (global-set-key (kbd "s-x") 'clipboard-kill-region)
#+END_SRC

** Make the bell less noisy
I hate the emacs bell. I'm thinking of maybe just disabling it
entirely, but I'm doing this dumb thing instead.[[https://www.emacswiki.org/emacs/AlarmBell][ From here.]]

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function
        (lambda ()
          (unless (memq this-command '(isearch-abort
                                       abort-recursive-edit
                                       exit-minibuffer
                                       keyboard-quit
                                       keyboard-escape-quit))
            (ding))))
#+END_SRC

At the very least, make it visible instead of audible

#+BEGIN_SRC emacs-lisp
  (setq visible-bell t)
#+END_SRC

** Backup settings
Emacs pollutes the file system way to much with weird lockfiles and
backups. This probably helps. Got it from emacswiki or something.

#+BEGIN_SRC emacs-lisp
  (setq
   backup-by-copying t
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t
   create-lockfiles nil)

  (setq backup-directory-alist `((".*" . ,temporary-file-directory)))
  (setq auto-save-file-name-transforms `((".*" ,temporary-file-directory t)))
#+END_SRC

** Basic emacs keys

Right Cmd is meta, option is just option. Remapping escape to be more
impactful.

#+BEGIN_SRC emacs-lisp
  (setq mac-option-modifier nil)
  (setq mac-right-command-modifier 'meta)

  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
#+END_SRC

However, 'keyboard-escape-quit should never close windows, that's just
annoying

#+BEGIN_SRC emacs-lisp
  ;; from https://stackoverflow.com/a/40390199/220961

  (defadvice keyboard-escape-quit
    (around keyboard-escape-quit-dont-close-windows activate)
    (let ((buffer-quit-function (lambda () ())))
      ad-do-it))
#+END_SRC

** Truncate lines
No wrapping, basically. I'm not sure I like this for every buffer,
maybe just code?

#+BEGIN_SRC emacs-lisp
(set-default 'truncate-lines t)
#+END_SRC

Definitely do wrap the compilation buffer though

#+BEGIN_SRC emacs-lisp
  (add-hook 'compilation-mode-hook (lambda () (setq truncate-lines nil)))

#+END_SRC
** Scroll options
Scrolling how I like it. scroll-conservatively makes it so that
scolling across the screen doesn't recenter the line.
#+BEGIN_SRC emacs-lisp

  (setq scroll-conservatively 101)
  (setq scroll-margin 5)

#+END_SRC
** Sentences end in single space.
The default value is insanity.

#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC
** Fix whitespace before saving
#+BEGIN_SRC emacs-lisp
  ; (add-hook
  ;  'before-save-hook
  ;  (lambda ()
  ;    (when (and (bound-and-true-p evil-mode) (evil-normal-state-p))
  ;      (delete-trailing-whitespace))))
#+END_SRC

*** DONE don't do this if we're in insert state
This combined with "save with defocus has a problem, which is that if
you're in insert state on an empty indented line, ready to start
typing but you switch focus, the indentation disappears (because when
you defocus, it saves, and when it saves, it removes trailing
whitespace)

FIXED: only fix whitespace on defocus when you're in evil-normal-state

** Save on defocus
Save all file-tracking buffers on defocus. Neat!

#+BEGIN_SRC emacs-lisp
  (add-hook 'focus-out-hook (lambda () (save-some-buffers t)))
#+END_SRC

** Use y/n instead of yes / no
Simpler prompt

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Global auto-revert
Reload files that change on disk, through git or other editors or
whatever.

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
#+END_SRC
** Tab settings
Tabs are 4 characters, c offset is 4, and replace tabs with spaces by
default.

#+BEGIN_SRC emacs-lisp
  (setq-default
   tab-width        4
   c-basic-offset   4)
   ;indent-tabs-mode nil)
#+END_SRC
** Compile/recompile with F5

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "S-<f5>") 'compile)
  (global-set-key (kbd "<f5>") 'recompile)
#+END_SRC
** Use ido-mode
#+BEGIN_SRC emacs-lisp
  (ido-mode t)
#+END_SRC
* Custom functions
** Move lines up/down
Move lines up and down. I usually bind these to Alt+j/k in normal
state. Functions from: [[https://www.emacswiki.org/emacs/MoveLine][EmacsWiki: Move Line]]

#+BEGIN_SRC emacs-lisp
  (defmacro save-column (&rest body)
    `(let ((column (current-column)))
       (unwind-protect
           (progn ,@body)
         (move-to-column column))))
  (put 'save-column 'lisp-indent-function 0)

  (defun gk/move-line-up ()
    (interactive)
    (save-column
      (transpose-lines 1)
      (forward-line -2)))

  (defun gk/move-line-down ()
    (interactive)
    (save-column
      (forward-line 1)
      (transpose-lines 1)
      (forward-line -1)))
#+END_SRC

** Insert empty line
Move line down, inserting an empty line. Usually mapped to RET in
normal state.
#+BEGIN_SRC emacs-lisp
  (defun gk/insert-empty-line (count)
    (interactive "p")
    (save-excursion
      (beginning-of-line)
      (open-line count)))
#+END_SRC

** Kill number and put it into calc
#+BEGIN_SRC emacs-lisp
  (defun gk/kill-number-into-calc ()
    (interactive)
    (save-excursion
      (let ((start (point))
            (end (progn
                   (re-search-forward "[0-9]*" (line-end-position) t)
                   (point))))
        (kill-region start end)))
    (calc)
    (calc-yank 10))
#+END_SRC
 
*** TODO make it work for floats

** Show face under cursor
#+BEGIN_SRC emacs-lisp
  (defun gk/what-face (pos)
    (interactive "d")
    (let ((face (or (get-char-property (point) 'read-face-name)
                    (get-char-property (point) 'face))))
      (if face (message "Face: %s" face) (message "No face at %d" pos))))
#+END_SRC

** Compile with make
Run compile with makefile in first ancestor directory with one in it.

#+BEGIN_SRC emacs-lisp
  (defun gk/compile-with-make ()
    "Get folder containing makefile, upwards in hierarchy"
    (interactive)
    (compile (format "make -C %s" (locate-dominating-file "." "Makefile"))))


#+END_SRC

** Change default font sizes
Functions to change the default font size. I don't like emacs default
implementation of this, it changes the font size buffer-locally.

#+BEGIN_SRC emacs-lisp
  (defun gk/increase-default-font-size (&optional step)
    "Increase the default font size"
    (interactive "P")
    (let* ((old-size (face-attribute 'default :height))
           (new-size (+ old-size (or step 10))))

      (set-face-attribute 'default nil :height new-size)

      (message (concat "Default font size is now " (number-to-string new-size)))))

  (defun gk/decrease-default-font-size (&optional step)
    "Decrease the default font size"
    (interactive "P")
    (gk/increase-default-font-size (- 0 (or step 10))))
#+END_SRC

* Look options
** Theme
Keep switching these...
*** Base16
#+BEGIN_SRC emacs-lisp
  (use-package base16-theme
    :ensure t
    :config
    (setq base16-distinct-fringe-background nil)
    (load-theme 'base16-gruvbox-dark-hard t))
#+END_SRC
*** Others
#+BEGIN_SRC emacs-lisp

;(use-package gruvbox-theme
;  :ensure t
;  :config
;  (load-theme 'gruvbox t))
; (use-package solarized-theme
;   :ensure t
;   :config
;   (setq solarized-use-variable-pitch nil
;         solarized-scale-org-headlines nil
;         solarized-use-more-italic t)
;
;   (load-theme 'solarized-dark t))
;(use-package zerodark-theme
;  :ensure t
;  :config
;  (zerodark-setup-modeline-format))
;(use-package darktooth-theme
;  :ensure t
;  :config
;  (load-theme 'darktooth t)
;  (darktooth-modeline))
#+END_SRC
** Faces
The most important setting of all!

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil :height 150 :foundry "Matt" :family "Triplicate T4c")
#+END_SRC


Use italics and bold more liberally.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'font-lock-type-face nil :slant 'italic)
  (set-face-attribute 'font-lock-comment-face nil :slant 'italic)
  (set-face-attribute 'font-lock-keyword-face nil :weight 'bold)
#+END_SRC

The "outline" faces are what's used for org headlines (at least in
base16 themes), and they inherit from the faces i customized above,
which leads to various org headlines being bold and italic. So,
hard-set these headlines to be regular weight and slant.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'outline-1 nil :weight 'normal :slant 'normal)
  (set-face-attribute 'outline-2 nil :weight 'normal :slant 'normal)
  (set-face-attribute 'outline-3 nil :weight 'normal :slant 'normal)
  (set-face-attribute 'outline-4 nil :weight 'normal :slant 'normal)
  (set-face-attribute 'outline-5 nil :weight 'normal :slant 'normal)
  (set-face-attribute 'outline-6 nil :weight 'normal :slant 'normal)
  (set-face-attribute 'outline-7 nil :weight 'normal :slant 'normal)
  (set-face-attribute 'outline-8 nil :weight 'normal :slant 'normal)
#+END_SRC
** GUI
No toolbar or scrollbar. Maybe no fringe?

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  ;(set-face-attribute 'fringe nil :background nil)
#+END_SRC

Enable relative line numbers

#+BEGIN_SRC emacs-lisp
  (setq-default display-line-numbers 'relative)
#+END_SRC

But no line numbers in magit

#+BEGIN_SRC emacs-lisp
  (add-hook 'magit-pre-display-buffer-hook
            (lambda () (setq display-line-numbers nil)))
#+END_SRC
Highlight current line

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode t)
#+END_SRC

Start maximized

#+BEGIN_SRC emacs-lisp
  (toggle-frame-maximized)
#+END_SRC

** Matching parens
Highlight matching parens

#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
#+END_SRC

* Packages
** General key binding
Not sure i need this, really. Maybe I should try redoing my keymaps in
an "emacs native" way.

#+BEGIN_SRC emacs-lisp
  (use-package general
    :ensure t)
#+END_SRC

** Company
Company for autocompletion
#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config
    (global-company-mode t)

    ; (add-to-list 'company-backends 'company-files)

    ;; Limit backends, tabnine will do most of the work
    ;; (setq company-backends '(company-capf company-files))

    (add-hook 'text-mode-hook (lambda () (company-mode -1)))

    ;; Trigger completion immediately.
    (setq-default company-idle-delay 0.25)

    ;; Number the candidates (use M-1, M-2 etc to select completions).
    (setq company-show-numbers t)

    ;; Use the tab-and-go frontend.
    ;; Allows TAB to select and complete at the same time.
    ;; (company-tng-configure-default)
    (setq company-frontends
          '(;; company-tng-frontend
            company-pseudo-tooltip-frontend
            company-echo-metadata-frontend)))
#+END_SRC
** Projectile

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :config
    (projectile-global-mode +1))
#+END_SRC

** Magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :config
    (setq magit-no-confirm '(stage-all-changes unstage-all-changes))
    (use-package evil-magit
      :ensure t)
    (add-to-list 'magit-section-initial-visibility-alist '(stashes . hide)))
#+END_SRC

** Yasnippet
Yas, queen.

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (use-package yasnippet-snippets
      :ensure t)

    ;(yas-global-mode 1)
    )
#+END_SRC

*** TODO get better at snippets. figure out c for-snippet
** which-key

#+BEGIN_SRC emacs-lisp
    (use-package which-key
      :ensure t
      :config (which-key-mode 1))
#+END_SRC
** helm-ls-git
#+BEGIN_SRC emacs-lisp
  (use-package helm-ls-git
    :ensure t)
#+END_SRC
** ledger
#+BEGIN_SRC emacs-lisp
  (use-package ledger-mode
    :ensure t
    :config
    ; (setq-default ledger-binary-path "/usr/local/bin/ledger")

    ; (add-to-list 'evil-motion-state-modes 'ledger-report-mode)
    ; (add-to-list 'evil-motion-state-modes 'ledger-reconcile-mode)

    (setq ledger-clear-whole-transactions t
          ledger-reconcile-default-commodity "kr"

          ledger-reconcile-buffer-account-max-chars 16
          ledger-reconcile-buffer-line-format "%(date)s %-22(payee)s %-16(account)s %12(amount)s\n"
          ledger-reconcile-buffer-payee-max-chars 20
          ledger-reconcile-default-commodity "kr")

    (add-to-list 'evil-emacs-state-modes 'ledger-reconcile-mode)
    (add-to-list 'evil-emacs-state-modes 'ledger-report-mode))
#+END_SRC
** neotree
#+BEGIN_SRC emacs-lisp
    (use-package neotree
      :ensure t
      :config
      (setq neo-theme (if (display-graphic-p) 'icons 'arrow))
      (setq projectile-switch-project-action 'neotree-projectile-action))
#+END_SRC

** expand-region
Expands region by semantic units

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :config
    (global-set-key (kbd "C-+") 'er/expand-region))
#+END_SRC

** tabnine
Lets try this thing out!

#+BEGIN_SRC emacs-lisp
  (use-package company-tabnine
    :ensure t
    :config
    (add-to-list 'company-backends #'company-tabnine t))
#+END_SRC

To install binary, run `M-x company-tabnine-install-binary`

** Telephone line
For the modeline

#+BEGIN_SRC emacs-lisp
  (use-package telephone-line
    :ensure t
    :config
    (setq telephone-line-primary-left-separator 'telephone-line-identity-right
          telephone-line-secondary-left-separator 'telephone-line-flat
          telephone-line-primary-right-separator 'telephone-line-identity-left
          telephone-line-secondary-right-separator 'telephone-line-flat
          telephone-line-height 50)
    (telephone-line-mode 1))
#+END_SRC

* Helm
** Load

#+BEGIN_SRC emacs-lisp

  (use-package helm
    :ensure t)

#+END_SRC

** Keymaps

#+BEGIN_SRC emacs-lisp
  (general-define-key
   "M-x"     'helm-M-x
   "C-M-x"   'execute-extended-command
   "C-h a"   'helm-apropos
   "C-x b"   'helm-mini)
#+END_SRC

** Grepping
*** Search entire git repo

#+BEGIN_SRC emacs-lisp

(defun helm-rg-git-root (arg)
  "Run helm-do-grep-ag in git root level, if there is one, otherwise default-directory"
  (interactive "P")
  (let* ((git-root (magit-toplevel))
         (directory (if git-root git-root default-directory)))
    (helm-grep-ag directory arg)))

#+END_SRC

*** Use rg for grepping

#+BEGIN_SRC emacs-lisp
  (setq helm-grep-ag-command
        "rg --color=always --smart-case --no-heading --line-number %s %s %s")
#+END_SRC

** Use helm-ls-git
#+BEGIN_SRC emacs-lisp
  ;(use-package helm-ls-git
  ;  :ensure t
  ;  :config
  ;  (helm-ls-git-build-ls-git-source)
  ;  (add-to-list 'helm-mini-default-sources 'helm-source-ls-git t))
#+END_SRC
** Customize helm-mini
#+BEGIN_SRC emacs-lisp
  ;(setq helm-mini-default-sources
  ;      '(helm-source-buffers-list
  ;        helm-source-recentf
  ;        helm-source-buffer-not-found))
#+END_SRC

* Evil mode
** Keymaps
#+BEGIN_SRC emacs-lisp
  (defun evil-set-keys ()
    (general-define-key
     :states 'motion
     "ö" 'evil-backward-paragraph
     "ä" 'evil-forward-paragraph
     "å" 'evil-first-non-blank
     "Å" 'evil-end-of-line)

    (general-define-key
     :states 'normal
     ",s"                'mark-whole-buffer
     ",f"                'helm-find-files
     ",p"                'helm-ls-git-ls
     ",b"                'helm-mini
     ",m"                'magit-status
     ",g"                'helm-rg-git-root  ; defined in helm section
     ",k"                'kill-this-buffer
     ",h"                'helm-apropos
     ",c"                'gk/kill-number-into-calc
     "√"                 'gk/move-line-down
     "ª"                 'gk/move-line-up
     "π"                 'evil-paste-increment-and-yank
     "S"                 'evil-stamp
     "+"                 'flycheck-next-error
     "-"                 'flycheck-previous-error
     "<deletechar>"      'clear-line
     "<left>"            'evil-window-left
     "<right>"           'evil-window-right
     "<up>"              'evil-window-up
     "<down>"            'evil-window-down
     "<backspace>"       'evil-ex-nohighlight
     "RET"               'gk/insert-empty-line
     "z"                 'save-buffer
     "SPC"               'helm-M-x)

    (general-define-key
     :states 'visual
     "gc"   'comment-region
     "gC"   'uncomment-region)

    (general-define-key
        :states 'insert
        "<tab>"   'tab-to-tab-stop
        "ö"       (lambda () (interactive) (insert "{") (indent-according-to-mode))
        "ä"       (lambda () (interactive) (insert "}") (indent-according-to-mode))
        "Ö"       (lambda () (interactive) (insert "["))
        "Ä"       (lambda () (interactive) (insert "]"))
        "{"       (lambda () (interactive) (insert "ö"))
        "}"       (lambda () (interactive) (insert "ä"))
        "["       (lambda () (interactive) (insert "Ö"))
        "]"       (lambda () (interactive) (insert "Ä"))))

  (add-hook 'evil-mode-hook 'evil-set-keys)
#+END_SRC
** Search module
Makes gn motion work in cgn/dgn
#+BEGIN_SRC emacs-lisp
  (setq evil-search-module 'evil-search)
#+END_SRC
** Use j/k to get out of insert mode
This works badly, so i'm disabling it for now. Since caps-lock has
been mapped to escape, it's no longer really needed as much.
#+BEGIN_SRC emacs-lisp
  ;(add-hook 'evil-mode-hook
  ; (lambda ()
  ;   (use-package evil-escape
  ;     :ensure t
  ;     :config
  ;     (evil-escape-mode t)
  ;     (setq-default evil-escape-key-sequence "jk"))))
#+END_SRC

** Alignment operator
#+BEGIN_SRC emacs-lisp
  (add-hook 'evil-mode-hook
   (lambda ()
     (use-package evil-lion
       :ensure t
       :config
       (evil-lion-mode t))))
#+END_SRC

** Stamp command
#+BEGIN_SRC emacs-lisp
  (evil-define-command evil-stamp ()
    "Replace word with latest yank"
    (interactive)
    (evil-with-single-undo
      (save-excursion
          (kill-word 1)
          (evil-paste-from-register ?0))))

#+END_SRC
** Paste line and bump first number

#+BEGIN_SRC emacs-lisp
  (defun increment-first-number-in-line (inc)
    "Increment the first number in a line"
    (interactive "p")
    (save-match-data
      (save-excursion
        (let* ((match-number (lambda () (string-to-number (match-string 0))))
               (increment-match (lambda () (+ (or inc 1) (funcall match-number)))))
          (move-beginning-of-line nil)
          (cond ((re-search-forward "-?[0-9]+" (point-at-eol) t)
                 (replace-match (number-to-string (funcall increment-match)))))))))

  (evil-define-command evil-paste-increment-and-yank (repeat)
    "Paste, increment the first number in line, then yank again"
    (interactive "p")
    (evil-with-single-undo
      (save-excursion (evil-paste-after repeat))
      (dotimes (i repeat)
        (next-line)
        (increment-first-number-in-line (+ i 1)))
      (call-interactively 'evil-yank-line)))
#+END_SRC

*** TODO bump all numbers in line
** Delete to clear a line
#+BEGIN_SRC emacs-lisp
  (defun clear-line ()
    "Clear entire current line"
    (interactive)
    (move-beginning-of-line 1)
    (kill-line))
#+END_SRC
** Indent text object
Creates a new text object for indents, with keys ii and ai (i.e. dii,
vii, cii, etc)

#+BEGIN_SRC emacs-lisp
  (add-hook 'evil-mode-hook
            (lambda ()
              (use-package evil-indent-plus
                :ensure t
                :config
                (evil-indent-plus-default-bindings))))
#+END_SRC
** Load it

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :config

    (evil-mode t))
#+END_SRC
* Org mode
Org mode folders
#+BEGIN_SRC emacs-lisp
   (setq org-directory           "~/Dropbox/Org"
         org-archive-location    "~/Dropbox/Org/archive.org::* Archive"
         org-default-notes-file  "~/Dropbox/Org/notes.org"
         org-default-agenda-file "~/Dropbox/Org/agenda.org"
         org-agenda-files        '("~/Dropbox/Org/notes.org" "~/Dropbox/Org/agenda.org")
         org-agenda-window-setup 'current-window)
#+END_SRC

Initialize babel (do i need to do this?)

#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((R . t)
     (emacs-lisp . t)
     (gnuplot . t)
     (ledger . t)
     (python . t)))
#+END_SRC

Don't ask for confirmation to execute stuff

#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate nil        ;; for running code blocks
        org-confirm-elisp-link-function nil   ;; for elisp links
        org-confirm-shell-link-function nil)  ;; for shell links
#+END_SRC
** Agenda
Show two weeks in agenda
#+BEGIN_SRC emacs-lisp
(setq org-agenda-span 14)
#+END_SRC
** Capture
I should start using this at some point!
*** Key binding
#+BEGIN_SRC emacs-lisp
  (general-define-key
   "C-c c" 'org-capture)
#+END_SRC
*** Templates
#+BEGIN_SRC emacs-lisp

#+END_SRC
** Evil
Better evil integration

#+BEGIN_SRC emacs-lisp
  (use-package evil-org
    :ensure t
    :after org
    :config
    (add-hook 'org-mode-hook 'evil-org-mode)
    (add-hook 'evil-org-mode-hook
              (lambda ()
                (evil-org-set-key-theme))))
#+END_SRC

Don't evil-autoindent in org
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook (lambda () (setq evil-auto-indent nil)))
#+END_SRC

Alt+j/k moves lines in evil mode, in org mode it moves headings
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :states 'normal
   :keymaps 'org-mode-map
   "√"          'org-metadown
   "ª"          'org-metaup)
#+END_SRC

ö/ä is paragraph motion in evil mode, Ö/Ä is heading motion in evil
mode.

#+BEGIN_SRC emacs-lisp
  (general-define-key
   :states '(motion visual)
   :keymaps 'org-mode-map
   "Ö" 'outline-previous-visible-heading
   "Ä" 'outline-next-visible-heading)
#+END_SRC
** Keys
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :keymaps 'org-mode-map
   "<C-M-return>" 'org-insert-heading-after-current)

  (general-define-key
   :keymaps 'org-src-mode-map
   :states 'normal
   "z" 'org-edit-src-exit)

#+END_SRC
** Fontify source code
#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC

** Bullets
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :ensure t
    :config
    (add-hook 'org-mode-hook 'org-bullets-mode))
#+END_SRC

** Indent
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC
** Auto-fill
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'auto-fill-mode)
#+END_SRC
** Trello
#+BEGIN_SRC emacs-lisp
  ; (use-package org-trello
  ;   :ensure t
  ;   :config
  ;   (setq org-trello-files '("~/Dropbox/Org/Trello/alfie3.org"))
  ;   (add-hook 'org-trello-mode-hook (lambda () (setq truncate-lines nil))))
#+END_SRC
** Add pdflatex to path
#+BEGIN_SRC emacs-lisp
  (setenv "PATH" (concat (getenv "PATH") ":/Library/TeX/texbin"))
#+END_SRC
* Languages
** Indentation
#+BEGIN_SRC emacs-lisp
  (c-set-offset 'arglist-intro '+)
  (c-set-offset 'arglist-cont '0)
  (c-set-offset 'arglist-cont-nonempty '+)
  (c-set-offset 'arglist-close '+)

#+END_SRC
** C#
Use tabs instead of spaces

#+BEGIN_SRC emacs-lisp
  (add-hook 'csharp-mode-hook
            (lambda ()
            (setq indent-tabs-mode t)))
#+END_SRC

Flycheck off for now, it's buggy with omnisharp

#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'csharp-mode-hook
  ;;           (lambda ()
  ;;             (flycheck-mode 1)
  ;;             (setq flycheck-error-list-minimum-level 'error)
  ;;             (setq flycheck-navigation-minimum-level 'error)))
#+END_SRC

I forget why, but i need to set this path for some reason.

#+BEGIN_SRC emacs-lisp
  (setenv "PATH"
          (concat
           (getenv "PATH")
           ":/Library/Frameworks/Mono.framework/Versions/Current/Commands"))
#+END_SRC

Use omnisharp

#+BEGIN_SRC emacs-lisp
  (use-package omnisharp
    :ensure t
    :config
    (add-hook 'csharp-mode-hook 'omnisharp-mode)
    ; (eval-after-load 'company
    ;   '(add-to-list 'company-backends 'company-omnisharp))
    )

#+END_SRC

** C
*** Indendtation
#+BEGIN_SRC emacs-lisp
  (setq c-basic-offset 4)
#+END_SRC

** C++
C/C++ language server

#+BEGIN_SRC emacs-lisp

  ;; (use-package lsp-mode
  ;;   :ensure t)

  ;; (use-package cquery
  ;;   :ensure t
  ;;   :config
  ;;   (setq cquery-executable "/usr/local/bin/cquery"
  ;;         cquery-extra-args '("--log-file=/tmp/cqlog.txt"))
  ;;   (add-hook 'c-mode-hook 'lsp-cquery-enable)
  ;;   (add-hook 'c++-mode-hook 'lsp-cquery-enable))

  ;; (use-package company-lsp
  ;;   :ensure t
  ;;   :config (push 'company-lsp company-backends))
#+END_SRC
** Shaderlab
#+BEGIN_SRC emacs-lisp
  (use-package shader-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.shader\\'" . shader-mode))
    (add-to-list 'auto-mode-alist '("\\.compute\\'" . shader-mode)))

#+END_SRC

** Emacs Lisp

Eval and print with M-ret and S-ret. Not sure if this is such a good
idea, but it's neat sometimes.
#+BEGIN_SRC emacs-lisp
  (defun evil-eval-and-print-sexp ()
    (interactive)
    (evil-append 1 0 nil)
    (eval-print-last-sexp)
    (evil-normal-state))

  (general-define-key
   :keymaps '(lisp-interaction-mode-map emacs-lisp-mode-map)
   :states '(normal insert)
   "<M-return>" 'evil-eval-and-print-sexp
   "<S-return>" 'eval-last-sexp)
#+END_SRC

** Lua
Add lua mode

#+BEGIN_SRC emacs-lisp
  (use-package lua-mode
    :ensure t
    :config
    (add-hook 'lua-mode-hook (lambda () (setq indent-tabs-mode t))))
#+END_SRC

Lua prettyprinter. Requires that lua is installed, as well as the
inspect luarocks package

#+BEGIN_SRC emacs-lisp
  (defun gk/lua-pretty-print (&optional b e)
    (interactive)
    (if mark-active
        (gk/lua-pretty-print-region (region-beginning) (region-end))
      (save-excursion
        (set-mark (point-at-bol))
        (goto-char (point-at-eol))
        (gk/lua-pretty-print-region (region-beginning) (region-end)))))


    (defun gk/lua-pretty-print-region (&optional start end)
      (interactive "r")
      (let* ((lua-code
              (concat "inspect = require 'inspect'\n"
                      "local input = io.read('*a')\n"
                      "local table, err = load('x = {' .. input .. '}; return x[1]');\n"
                      "if err then\n"
                      "  io.write(input)\n"
                      "else\n"
                      "  io.write(inspect(table()))\n"
                      "end\n"))
             (command (concat "lua -e \"" lua-code "\"")))
        (shell-command-on-region start end command t t)
        (indent-region start end)))
#+END_SRC
* Start-up
** Split window into default buffers
#+BEGIN_SRC emacs-lisp
    (setq inhibit-splash-screen t
          inhibit-startup-message t
          inhibit-startup-echo-area-message t)

    (defun default-window-setup ()
      (interactive)
      (delete-other-windows)
      (split-window-right)
      (switch-to-buffer "*scratch*")
      (other-window 1 nil)
      (find-file org-default-notes-file)
      (other-window 1 nil))

    (default-window-setup)
#+END_SRC
** Temp
#+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :ensure t
      :config
      (global-flycheck-mode t))
#+END_SRC
